"use server"
import {sql} from "@/lib/sql/client";
import {
  createHnswIndex, getUserId,
  isSupabaseTableExists
} from "@/lib/supabase/utils";
import {createClient} from "@/lib/supabase/client/server";
import {UserDocument} from "@/lib/types/document";
import {embeddingWithVoyageLaw} from "@/lib/ai/voyage/embedding";
import {supabaseClient} from "@/lib/supabase/supabaseClient";

export const createUserDocumentsTable = async (tableName: string) => {
  try {
    await sql`
      CREATE TABLE ${sql(tableName)} (
        id bigint generated by default as identity PRIMARY KEY,
        content text,
        filename text,
        index text,
        metadata json,
        embedding_openai halfvec(3072),
        embedding_voyage vector(1024)
      );
    `;
  } catch (error) {
    console.error('Error creating user documents table:', error);
  }
}

export const getTableName = async () => {
  const userId = await getUserId();
  return `documents_${userId}`;
}

// create a function to match documents using cosine distance (<=>)
const createMatchDocumentsFunction = async (tableName: string) => {
  const userId = await getUserId();
  const functionName = `match_documents_${userId}`;
  await sql`
    create or replace function ${sql(functionName)} (
      query_embedding vector(1024),
      match_threshold float,
      match_count int
    )
    returns setof ${sql(tableName)}
    language sql
    as $$
      select *
      from ${sql(tableName)}
      where ${sql(tableName)}.embedding_voyage <=> query_embedding < 1 - match_threshold
      order by ${sql(tableName)}.embedding_voyage <=> query_embedding asc
      limit least(match_count, 200);
    $$;
  `;
}

// checkUserDocumentTable creates the table if it does not exist
export const checkUserDocumentTable = async () => {
  const tableName = await getTableName();
  const isTableExist = await isSupabaseTableExists(tableName);
  if (!isTableExist) {
    await createUserDocumentsTable(tableName);
    await createHnswIndex(tableName, "embedding_voyage");
    await createMatchDocumentsFunction(tableName);
  }
  return tableName;
}

export const insertDocument = async (
  metadata: Record<string, any>,
  chunk: string,
  tableName: string,
  filename: string,
  index: string
): Promise<Pick<UserDocument, "id" | "content"> | null> => {
  const supabase = createClient();
  const voyageApiKeys = [
    process.env.VOYAGE_AI_API_KEY_ANALYSIS_1,
    process.env.VOYAGE_AI_API_KEY_ANALYSIS_2,
    process.env.VOYAGE_AI_API_KEY_ANALYSIS_3,
  ];

  // Ensure all API keys are present
  if (voyageApiKeys.some((key) => !key)) {
    throw new Error("One or more VOYAGE_AI_API_KEY_ANALYSIS environment variables are not set");
  }

  const RETRY_DELAY = 2000;

  // Retry logic to get embedding
  const getEmbeddingWithRetry = async (chunk: string): Promise<number[]> => {
    let attempt = 0;

    while (true) {
      for (let i = 0; i < voyageApiKeys.length; i++) {
        const voyageApiKey = voyageApiKeys[i];
        if (!voyageApiKey) throw new Error("Voyage API key is missing");

        attempt++;
        try {
          console.log(`Attempt ${attempt} with API key ${i + 1}`);
          const embeddingVoyageResponse = await embeddingWithVoyageLaw(chunk, voyageApiKey);
          const embedding = embeddingVoyageResponse?.data[0]?.embedding;

          if (embedding) {
            console.log(`Success after ${attempt} attempts with API key ${i + 1}`);
            return embedding;
          } else {
            console.warn(`Attempt ${attempt} failed for API key ${i + 1}`);
          }
        } catch (error) {
          console.error(`Error on attempt ${attempt} with API key ${i + 1}:`, error);
        }

        // Delay before the next attempt
        console.log(`Retrying after ${RETRY_DELAY}ms...`);
        await new Promise((resolve) => setTimeout(resolve, RETRY_DELAY));
      }
    }
  };

  try {
    // Get embedding with retry logic
    const embeddingVoyage = await getEmbeddingWithRetry(chunk);

    // Insert the document into the database
    const { data, error } = await supabase
      .from(tableName)
      .insert([
        {
          content: chunk,
          filename: filename,
          index: index,
          metadata: JSON.stringify(metadata),
          embedding_voyage: embeddingVoyage,
        },
      ])
      .select("id, content");

    if (error) {
      console.error("Error inserting document:", error);
      throw error;
    }

    return data ? data[0] : null;
  } catch (err) {
    console.error("Unexpected error:", err);
    throw err;
  }
};

export const createFetchingUserDocumentChunksByIdsFunction = async (tableName: string) => {
  const functionName = `match_${tableName}_by_ids`;
  await sql.unsafe(`
    create or replace function ${functionName}(
      query_embedding vector(1024),
      match_threshold double precision,
      match_count int,
      id_list bigint[]
    )
    returns setof ${tableName}
    language plpgsql
    as $$
    BEGIN
      RETURN QUERY
        WITH selected_entries AS (
            SELECT ld.id, ld.embedding_voyage
            FROM ${tableName} ld
            WHERE ld.id = ANY(id_list)
            AND (ld.embedding_voyage <=> query_embedding) < 1 - match_threshold
        ),
        similarity_scores AS (
            SELECT se.id, se.content, se.filename, se.index, se.metadata,
                1 - (se.embedding_voyage <=> query_embedding) AS similarity
            FROM selected_entries se
        )
        SELECT ss.id::bigint, ss.content::text, ss.filename::text, 
               ss.index::text, ss.metadata::json, ss.similarity::double precision
        FROM similarity_scores ss
        ORDER BY ss.similarity DESC
        LIMIT match_count;
    END;
    $$;
  `);
};

export type MatchedUserDocument = Omit<UserDocument, "embedding_openai" | "embedding_voyage">

export const matchUserDocumentsAdaptiveRetrieval = async (embedding: number[], matchCount: number): Promise<Pick<MatchedUserDocument, "id">[]>  => {
  try {
    console.time("db user documents");
    const tableName = checkUserDocumentTable();
    const { data: matchedUserDocuments, error } = await supabaseClient.rpc(`match_${tableName}_adaptive`, {
      query_embedding: embedding,
      match_count: matchCount,
    });

    if (error) {
      console.error(`Error fetching user documents:`, error);
      return [];
    }
    console.timeEnd("db user documents");
    return matchedUserDocuments;
  } catch (err) {
    console.error(`cannot search user documents:`, err);
    return [];
  }
}

export const matchUserDocumentsByIds = async (embedding: number[], idList: bigint[], matchCount: number): Promise<MatchedUserDocument[]> => {
  try {
    console.time('call matchUserDocumentsByIds')
    const tableName = checkUserDocumentTable();
    const { data: matchedUserDocuments, error } = await supabaseClient.rpc(`match_${tableName}_by_ids`, {
      query_embedding: embedding,
      match_threshold: 0.2,
      match_count: matchCount,
      id_list: idList,
    });
    console.timeEnd('call matchUserDocumentsByIds');
    if (error) {
      console.error(`Error fetching user documents by IDs:`, error);
      return [];
    }
    return matchedUserDocuments;
  } catch (error) {
    console.error(`Exception occurred when fetching user documents from indexes:`, error);
    return [];
  }
}

export const matchUserDocuments = async (
  embedding: number[],
  threshold: number,
  matchCount: number
): Promise<MatchedUserDocument[]> => {
  const userId = await getUserId();
  const functionName = `match_documents_${userId}`;
  const formattedEmbedding = `[${embedding.join(',')}]`;

  return sql.unsafe(
    `
      SELECT id, content, filename, index, metadata
      FROM "${functionName}"($1, $2, $3)
    `,
    [formattedEmbedding, threshold, matchCount]
  );
};

export const searchMatchedUserDocuments = async (input: string): Promise<MatchedUserDocument[]> => {
  const voyageApiKey = process.env.VOYAGE_AI_API_KEY ??
    (() => {
      throw new Error('VOYAGE_AI_API_KEY is not set');
    })();
  const inputEmbeddingVoyageResponse = await embeddingWithVoyageLaw(input, voyageApiKey);
  if (!inputEmbeddingVoyageResponse) {
    return [];
  }
  const inputEmbeddingVoyage = inputEmbeddingVoyageResponse.data[0].embedding;
  const matchCount = 10;
  const threshold = 0.2;

  try {
    return await matchUserDocuments(inputEmbeddingVoyage, threshold, matchCount);
  } catch (error) {
    console.error('Error occurred while fetching user documents:', error);
    return [];
  }
}

export async function getUserDocumentsByIds(ids: bigint[]) {
  const tableName = await getTableName();
  const { data, error } = await supabaseClient
    .from(tableName)
    .select('id,content,filename,index,metadata')
    .in('id', ids);
  if (error) {
    console.error('Error fetching user documents:', error);
    return null;
  }
  return data;
}

export async function deleteDocuments() {
  const tableName = await getTableName();
  console.log('will delete documents table')
  const { error } = await supabaseClient
    .from(tableName)
    .delete()
    .neq('id', -1);
  if (error) {
    console.error('Error delete user documents:', error);
    throw error;
  }
}
